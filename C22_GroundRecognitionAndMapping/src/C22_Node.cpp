/**************************************************************************************
 * This is a template for the C22_GroundRecognitionAndMapping module for the robil project
 * The C22_GroundRecognitionAndMapping module goal is to provide a mapping of the terrain that surrounds the robot
 * The mapping include the planes that reside on each square 0.25 meter and their coefficients
 **************************************************************************************/

#include "ros/ros.h"
#include "pclPlane.h"
#include "MPlane.h"
#include "MapMatrix.h"
#include "C22_GroundRecognitionAndMapping/C22.h"
#include "C22_GroundRecognitionAndMapping/C22C24.h"
#include <C21_VisionAndLidar/C21_C22.h>
#include "sensor_msgs/PointCloud.h"
#include <pcl/correspondence.h>
#include <pcl/point_cloud.h>
#include <pcl/common/common_headers.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/io/pcd_io.h>
#include <pcl_ros/point_cloud.h>
#include <pcl/ModelCoefficients.h>
#include <pcl/point_types.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/filters/statistical_outlier_removal.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <iostream>
#include <pcl/io/pcd_io.h>
#include <iostream>
#include <boost/thread/thread.hpp>
#include <boost/bind.hpp>
#include <pcl/sample_consensus/sac_model_plane.h>
#include "C22_Node.h"
#include <tf/tf.h>
#include <pcl_ros/transforms.h>
#include <message_filters/subscriber.h>
#include <message_filters/synchronizer.h>
#include <message_filters/time_synchronizer.h>
#include <message_filters/sync_policies/approximate_time.h>
#include "std_srvs/Empty.h"
//c24 added includes
#include <nav_msgs/Odometry.h>
#include <sensor_msgs/Imu.h>

/**
 * this class represent the C22_Node,
 * it subscribe to the drc multisense topic and provide the Eagle eye mapping
 **/
C22_Node::C22_Node():
	pointCloud_sub(nh_,"/C21/C22",1),
	pos_sub(nh_,"/ground_truth_odom",1),
	sync( MySyncPolicy( 10 ),pointCloud_sub, pos_sub){

	sync.registerCallback( boost::bind( &C22_Node::callback, this, _1, _2) );
	_myMatrix=new MapMatrix();
	_myPlanes=new std::vector<pclPlane*>();
	ROS_INFO("C22 Online\n");
	//test1=nh_.subscribe("/C21/C22",1,&C22_Node::callback2,this);
	//test2=nh_.subscribe("/ground_truth_odom",1,&C22_Node::callback3,this);
	service = nh_.advertiseService("C22", &C22_Node::proccess, this); //Specifying what to do when a reconstructed 3d scene is requested
	service2 = nh_.advertiseService("C22/C24", &C22_Node::proccess2, this); //Specifying what to do when a reconstructed 3d scene is requested
	/*pcl::PointCloud<pcl::PointXYZ>::Ptr basic_cloud_ptr (new pcl::PointCloud<pcl::PointXYZ>);
	std::cout << "Genarating example point clouds.\n\n";
	// We're going to make an ellipse extruded along the z-axis. The color for
	for (float z(-1.0); z <= 1.0; z += 0.05)
	{
	  for (float angle(0.0); angle <= 360.0; angle += 5.0)
	  {
	    pcl::PointXYZ basic_point;
	    basic_point.x = 0.5 * std::cos (pcl::deg2rad(angle));
	    basic_point.y = std::sin (pcl::deg2rad(angle));
	    basic_point.z = z;
	    basic_cloud_ptr->points.push_back(basic_point);

	  }
	}
	basic_cloud_ptr->width = (int) basic_cloud_ptr->points.size ();
	basic_cloud_ptr->height = 1;
	boost::shared_ptr<pcl::visualization::PCLVisualizer> myviewer (new pcl::visualization::PCLVisualizer ("3D Viewer"));
	viewer=myviewer;
	viewer->setBackgroundColor (0, 0, 0);
	viewer->addPointCloud<pcl::PointXYZ> (basic_cloud_ptr, "reconstruction");
	viewer->addCoordinateSystem ( 1.0 );
	viewer->initCameraParameters ();*/
}

/**
 * The call back function executed when a service is requested
 * it must return true in order to work properly
 * @param req the request message, generated by the node requesting the service
 * @param res the response message, generated by the service node when a service is requested
 */
bool C22_Node::proccess(C22_GroundRecognitionAndMapping::C22::Request  &req,
	C22_GroundRecognitionAndMapping::C22::Response &res ){
	//ROS_INFO("recived request, trying to fetch data\n");
	res.drivingPath.row.resize(_myMatrix->data->size());
	res.drivingPath.robotPos.x=robotPos.x;
	res.drivingPath.robotPos.y=robotPos.y;
	res.drivingPath.robotPos.z=robotPos.z;
	res.drivingPath.xOffset=_myMatrix->xOffset;
	res.drivingPath.yOffset=_myMatrix->yOffset;
	for(int i=0;i<_myMatrix->data->size();i++){
		res.drivingPath.row.at(i).column.resize(_myMatrix->data->at(i)->size());
		for(int j=0;j<_myMatrix->data->at(i)->size();j++){
			res.drivingPath.row.at(i).column.at(j).status=_myMatrix->data->at(i)->at(j)->square_status;
			res.drivingPath.row.at(i).column.at(j).planes.resize(_myMatrix->data->at(i)->at(j)->square_Planes->size());
			for(int k=0;k<_myMatrix->data->at(i)->at(j)->square_Planes->size();k++){
				res.drivingPath.row.at(i).column.at(j).planes.at(k).x=_myMatrix->data->at(i)->at(j)->square_Planes->at(k)->coefficient_x;
				res.drivingPath.row.at(i).column.at(j).planes.at(k).y=_myMatrix->data->at(i)->at(j)->square_Planes->at(k)->coefficient_y;
				res.drivingPath.row.at(i).column.at(j).planes.at(k).z=_myMatrix->data->at(i)->at(j)->square_Planes->at(k)->coefficient_z;
				res.drivingPath.row.at(i).column.at(j).planes.at(k).d=_myMatrix->data->at(i)->at(j)->square_Planes->at(k)->coefficient_d;
			}
		}
	}
  return true;
}


/**
 * The call back function executed when a service is requested
 * it must return true in order to work properly
 * @param req the request message, generated by the node requesting the service
 * @param res the response message, generated by the service node when a service is requested
 */
bool C22_Node::proccess2(C22_GroundRecognitionAndMapping::C22C24::Request  &req,
	C22_GroundRecognitionAndMapping::C22C24::Response &res ){
	ROS_INFO("recived request, tying to fetch data\n");
	res.drivingPath.row.resize(_myMatrix->data->size());
	for(int i=0;i<_myMatrix->data->size();i++){
		res.drivingPath.row. at(i).column.resize(_myMatrix->data->at(i)->size());
		for(int j=0;j<_myMatrix->data->at(i)->size();j++){
			res.drivingPath.row.at(i).column.at(j).status=_myMatrix->data->at(i)->at(j)->square_status;
			res.drivingPath.row.at(i).column.at(j).height=-1000;
			for(int k=0;k<_myMatrix->data->at(i)->at(j)->square_Planes->size();k++){
				res.drivingPath.row.at(i).column.at(j).height=std::max(res.drivingPath.row.at(i).column.at(j).height,_myMatrix->data->at(i)->at(j)->square_Planes->at(k)->representing_point.y);
			}
		}
	}
  return true;
}

/**
 * The call back function executed when a new point cloud has arrived
 */
void C22_Node::callback(const C21_VisionAndLidar::C21_C22::ConstPtr& pclMsg,const nav_msgs::Odometry::ConstPtr& pos_msg){
	 pcl::PointCloud<pcl::PointXYZ>cloud;
	 pcl::fromROSMsg<pcl::PointXYZ>(pclMsg->cloud,cloud);
	 pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_backup(cloud.makeShared());
	 /*
	  * this code segment filters the given cloud and lowers its resolution
	  */
	 //std::cout << "PointCloud before filtering has: " << cloud.points.size () << " data points." << std::endl; //*
	 // Create the filtering object: downsample the dataset using a leaf size of 5cm
	 pcl::VoxelGrid<pcl::PointXYZ> vg;
	 pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);
	 // create the radius outlier removal filter
	  vg.setInputCloud (cloud_backup);
	  vg.setLeafSize (0.01f, 0.01f, 0.01f);
	  vg.filter (*cloud_filtered);
	 pcl::StatisticalOutlierRemoval<pcl::PointXYZ> sor;
	  sor.setInputCloud (cloud_filtered);
	  sor.setMeanK (100);
	  sor.setStddevMulThresh (1.0);
	  sor.filter (*cloud_filtered);


	 tf::Transform trans;
	 trans.setOrigin(tf::Vector3(pclMsg->pose.position.x,pclMsg->pose.position.y,pclMsg->pose.position.z));
	 trans.setRotation(tf::Quaternion(pclMsg->pose.orientation.x,pclMsg->pose.orientation.y,pclMsg->pose.orientation.z,pclMsg->pose.orientation.w));
	 tf::Transform trans2;
	 	 trans2.setOrigin(tf::Vector3(pos_msg->pose.pose.position.x,pos_msg->pose.pose.position.y,pos_msg->pose.pose.position.z));
	 	 trans2.setRotation(tf::Quaternion(pos_msg->pose.pose.orientation.x,pos_msg->pose.pose.orientation.y,pos_msg->pose.pose.orientation.z,pos_msg->pose.pose.orientation.w));
	 tf::Transform trans3;
	 	 trans3.setOrigin(tf::Vector3(0.0,-0.002, 0.035 ));
	 	 trans3.setRotation(tf::Quaternion(-1.57,3.14,1.57));
	 Eigen::Matrix4f sensorToHead,headTopelvis,pelvisToWorld;
	 pcl_ros::transformAsMatrix(trans3, sensorToHead);
     pcl_ros::transformAsMatrix(trans, headTopelvis);
	 pcl_ros::transformAsMatrix(trans2, pelvisToWorld);

	 robotPos.x=pos_msg->pose.pose.position.x;
	 robotPos.y=pos_msg->pose.pose.position.y;
	 robotPos.z=pos_msg->pose.pose.position.z;
	 // transform pointcloud from sensor frame to fixed robot frame
	 pcl::transformPointCloud(*cloud_filtered, *cloud_filtered, sensorToHead);
	 pcl::transformPointCloud(*cloud_filtered, *cloud_filtered, headTopelvis);
	 pcl::transformPointCloud(*cloud_filtered, *cloud_filtered, pelvisToWorld);
	/*	viewer->spinOnce (100);
		if(!viewer->updatePointCloud(cloud_filtered,"reconstruction"))
			viewer->addPointCloud(cloud_filtered, "reconstruction");*/
	 _myMatrix->updateMapRelationToWorld(pos_msg->pose.pose.position.x,pos_msg->pose.pose.position.y);
	 //_myMatrix->clearMatrix();
	 pcl::PointCloud<pcl::PointXYZ>::Ptr cloudf_backup(cloud_filtered->makeShared());
	  /*
	   * while there are indices there are planes we haven't checked
	   */

	  while (1){

		  /*
		  * this is a definition of a segment, notice that it allows us to define its size
		  */
		  // Create the segmentation object for the planar model and set all the parameters
		  pcl::SACSegmentation<pcl::PointXYZ> seg;
		  pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
		  pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients);
		  seg.setOptimizeCoefficients (true);
		  seg.setModelType (pcl::SACMODEL_PLANE);
		  seg.setMethodType (pcl::SAC_RANSAC);
		  seg.setMaxIterations (100);
		  seg.setDistanceThreshold (0.05);
			  /*
			   * once we have defined a segment, we need to create clusters
			   */
		  seg.setInputCloud (cloud_filtered);
		  seg.segment (*inliers, *coefficients);
		 // std::cout << "size " <<inliers->indices.size()<< std::endl;
		  if(inliers->indices.size()==0)
			  break;
		  pclPlane *plane =new pclPlane();
		  plane->inliers=inliers;
		  plane->coefficients=coefficients;
		  _myPlanes->push_back(plane);


		  pcl::ExtractIndices<pcl::PointXYZ> extract;
		  //now we remove the plane we found from the cloud and search again
		  extract.setInputCloud (cloud_filtered);
		  extract.setIndices (inliers);	//problem only in eclipse, works->ignore
		  extract.setNegative (true);
		  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_temp (new pcl::PointCloud<pcl::PointXYZ>);
		  extract.filter (*cloud_temp);
		  cloud_filtered.swap(cloud_temp);
		  if(cloud_filtered->points.size()<10)
			  break;

	  }
	  _myMatrix->computeMMatrix(_myPlanes,cloudf_backup);//cloud_filtered);

	  while(_myPlanes->size()!=0){
		  pclPlane* temp=_myPlanes->back();
		  _myPlanes->pop_back();
		  delete temp;
	  }
	  delete _myPlanes;
	  _myPlanes=new std::vector<pclPlane*>();
	  cloud_backup.reset();
	  cloudf_backup.reset();
	  cloud_filtered.reset();
}

C22_Node *node22;
int main(int argc, char **argv)
{
  ros::init(argc, argv, "c22_groundReconition_and_mapping");
  node22=new C22_Node();
  while(ros::ok()){
	  ros::spin();
  }
  return 0;
}
