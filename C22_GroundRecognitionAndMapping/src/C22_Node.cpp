/**************************************************************************************
 * This is a template for the C22_GroundRecognitionAndMapping module for the robil project
 * The C22_GroundRecognitionAndMapping module goal is to provide a mapping of the terrain that surrounds the robot
 * The mapping include the planes that reside on each square 0.25 meter and their coefficients
 **************************************************************************************/

#include "ros/ros.h"
#include "pclPlane.h"
#include "MPlane.h"
#include "MapMatrix.h"
#include "C22_GroundRecognitionAndMapping/C22.h"
#include "C22_GroundRecognitionAndMapping/C22C24.h"
#include "sensor_msgs/PointCloud.h"
#include <pcl/correspondence.h>
#include <pcl/point_cloud.h>
#include <pcl/common/common_headers.h>
#include <pcl/visualization/pcl_visualizer.h>
#include <pcl/io/pcd_io.h>
#include <pcl_ros/point_cloud.h>
#include <pcl/ModelCoefficients.h>
#include <pcl/point_types.h>
#include <pcl/filters/extract_indices.h>
#include <pcl/filters/voxel_grid.h>
#include <pcl/segmentation/sac_segmentation.h>
#include <iostream>
#include <pcl/io/pcd_io.h>
#include <iostream>
#include <boost/thread/thread.hpp>
#include <pcl/sample_consensus/sac_model_plane.h>
#include "C22_Node.h"

//c24 added includes
#include <nav_msgs/Odometry.h>
#include <sensor_msgs/Imu.h>

/**
 * this class represent the C22_Node,
 * it subscribe to the drc multisense topic and provide the Eagle eye mapping
 **/
C22_Node::C22_Node(){
	_myMatrix=new MapMatrix();
	_myPlanes=new std::vector<pclPlane*>();
	pointCloud_sub=nh_.subscribe("/multisense_sl/points2",1,&C22_Node::callback,this);
	ROS_INFO("finished subscribing\n");
	service = nh_.advertiseService("C22", &C22_Node::proccess, this); //Specifying what to do when a reconstructed 3d scene is requested
	service2 = nh_.advertiseService("C22/C24", &C22_Node::proccess2, this); //Specifying what to do when a reconstructed 3d scene is requested

}

/**
 * The call back function executed when a service is requested
 * it must return true in order to work properly
 * @param req the request message, generated by the node requesting the service
 * @param res the response message, generated by the service node when a service is requested
 */
bool C22_Node::proccess(C22_GroundRecognitionAndMapping::C22::Request  &req,
	C22_GroundRecognitionAndMapping::C22::Response &res ){
	ROS_INFO("recived request, tying to fetch data\n");
	res.drivingPath.row.resize(_myMatrix->data->size());
	for(int i=0;i<_myMatrix->data->size();i++){
		res.drivingPath.row.at(i).column.resize(_myMatrix->data->at(i)->size());
		for(int j=0;j<_myMatrix->data->at(i)->size();j++){
			res.drivingPath.row.at(i).column.at(j).status=_myMatrix->data->at(i)->at(j)->square_status;
			res.drivingPath.row.at(i).column.at(j).planes.resize(_myMatrix->data->at(i)->at(j)->square_Planes->size());
			for(int k=0;k<_myMatrix->data->at(i)->at(j)->square_Planes->size();k++){
				res.drivingPath.row.at(i).column.at(j).planes.at(k).x=_myMatrix->data->at(i)->at(j)->square_Planes->at(k)->coefficient_x;
				res.drivingPath.row.at(i).column.at(j).planes.at(k).y=_myMatrix->data->at(i)->at(j)->square_Planes->at(k)->coefficient_y;
				res.drivingPath.row.at(i).column.at(j).planes.at(k).z=_myMatrix->data->at(i)->at(j)->square_Planes->at(k)->coefficient_z;
				res.drivingPath.row.at(i).column.at(j).planes.at(k).d=_myMatrix->data->at(i)->at(j)->square_Planes->at(k)->coefficient_d;
			}
		}
	}
  return true;
}


/**
 * The call back function executed when a service is requested
 * it must return true in order to work properly
 * @param req the request message, generated by the node requesting the service
 * @param res the response message, generated by the service node when a service is requested
 */
bool C22_Node::proccess2(C22_GroundRecognitionAndMapping::C22C24::Request  &req,
	C22_GroundRecognitionAndMapping::C22C24::Response &res ){
	ROS_INFO("recived request, tying to fetch data\n");
	res.drivingPath.row.resize(_myMatrix->data->size());
	for(int i=0;i<_myMatrix->data->size();i++){
		res.drivingPath.row. at(i).column.resize(_myMatrix->data->at(i)->size());
		for(int j=0;j<_myMatrix->data->at(i)->size();j++){
			res.drivingPath.row.at(i).column.at(j).status=_myMatrix->data->at(i)->at(j)->square_status;
			res.drivingPath.row.at(i).column.at(j).height=-1000;
			for(int k=0;k<_myMatrix->data->at(i)->at(j)->square_Planes->size();k++){
				res.drivingPath.row.at(i).column.at(j).height=std::max(res.drivingPath.row.at(i).column.at(j).height,_myMatrix->data->at(i)->at(j)->square_Planes->at(k)->representing_point.y);
			}
		}
	}
  return true;
}

/**
 * The call back function executed when a new point cloud has arrived
 */
void C22_Node::callback(const sensor_msgs::PointCloud2& pclMsg){
	//ROS_INFO("callback\n");
	 pcl::PointCloud<pcl::PointXYZ>cloud;
	 pcl::fromROSMsg<pcl::PointXYZ>(pclMsg,cloud);
	 pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_backup(cloud.makeShared());
	 /*
	  * this code segment filters the given cloud and lowers its resolution
	  */
	 //std::cout << "PointCloud before filtering has: " << cloud.points.size () << " data points." << std::endl; //*
	 // Create the filtering object: downsample the dataset using a leaf size of 5cm
	 pcl::VoxelGrid<pcl::PointXYZ> vg;
	 pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_filtered(new pcl::PointCloud<pcl::PointXYZ>);
	 vg.setInputCloud (cloud_backup);
	 vg.setLeafSize (0.05f, 0.05f, 0.05f);
	 vg.filter (*cloud_filtered);

	 _myMatrix->clearMatrix();
	 pcl::PointCloud<pcl::PointXYZ>::Ptr cloudf_backup(cloud_filtered->makeShared());

	  /*
	   * while there are indices there are planes we haven't checked
	   */

	  while (1){

		  /*
		  * this is a definition of a segment, notice that it allows us to define its size
		  */
		  // Create the segmentation object for the planar model and set all the parameters
		  pcl::SACSegmentation<pcl::PointXYZ> seg;
		  pcl::PointIndices::Ptr inliers (new pcl::PointIndices);
		  pcl::ModelCoefficients::Ptr coefficients (new pcl::ModelCoefficients);
		  seg.setOptimizeCoefficients (true);
		  seg.setModelType (pcl::SACMODEL_PLANE);
		  seg.setMethodType (pcl::SAC_RANSAC);
		  seg.setMaxIterations (100);
		  seg.setDistanceThreshold (0.05);
			  /*
			   * once we have defined a segment, we need to create clusters
			   */
		  seg.setInputCloud (cloud_filtered);
		  seg.segment (*inliers, *coefficients);
		 // std::cout << "size " <<inliers->indices.size()<< std::endl;
		  if(inliers->indices.size()==0)
			  break;
		  pclPlane *plane =new pclPlane();
		  plane->inliers=inliers;
		  plane->coefficients=coefficients;
		  _myPlanes->push_back(plane);


		  pcl::ExtractIndices<pcl::PointXYZ> extract;
		  //now we remove the plane we found from the cloud and search again
		  extract.setInputCloud (cloud_filtered);
		  extract.setIndices (inliers);	//problem only in eclipse, works->ignore
		  extract.setNegative (true);
		  pcl::PointCloud<pcl::PointXYZ>::Ptr cloud_temp (new pcl::PointCloud<pcl::PointXYZ>);
		  extract.filter (*cloud_temp);
		  cloud_filtered.swap(cloud_temp);
		  if(cloud_filtered->points.size()<10)
			  break;

	  }
	  _myMatrix->computeMMatrix(_myPlanes,cloudf_backup);//cloud_filtered);
	  while(_myPlanes->size()!=0){
		  pclPlane* temp=_myPlanes->back();
		  _myPlanes->pop_back();
		  delete temp;
	  }
	  delete _myPlanes;
	  _myPlanes=new std::vector<pclPlane*>();
	  cloud_backup.reset();
	  cloudf_backup.reset();
	  cloud_filtered.reset();
}

C22_Node *node22;
int main(int argc, char **argv)
{
  ros::init(argc, argv, "c22_groundReconition_and_mapping");
  node22=new C22_Node();
  while(ros::ok()){
	  ros::spin();
  }
  return 0;
}
