/**************************************************************************************
 * This is a template for the C23_ObjectRecognition module for the robil project
 * The C23_ObjectRecognition module goal is to provide a recognition of the object searched in the given frame
 *
 * There is no actual input/output at this time, this goes according to the current milestone
 * set at the robil managment meeting
 * 
 **************************************************************************************/
#include "C23_Node.hpp"
#include <ros/package.h>
#include <C23_ObjectRecognition/C23C0_OD.h>
#include <C23_ObjectRecognition/C23C0_ODIM.h>
#include "GeneralDetector.hpp"
#include <geometry_msgs/Twist.h>


//#define _LEARNING
//#define TESTING
//#define CREATING_IMAGES

static const char WINDOW[] = "Image window";


C23_Node::C23_Node(std::string left_camera,std::string right_camera) :
		it_(nh_),
		tldh_(NULL),
		x(-1), y(-1), width(-1), height(-1),
		left_image_sub_( it_, left_camera, 1 ),
		right_image_sub_( it_, right_camera, 1 ),
		sync( MySyncPolicy( 10 ), left_image_sub_, right_image_sub_ ),
		detect(false),done_processing(true)
	  {
		sync.registerCallback( boost::bind( &C23_Node::callback, this, _1, _2 ) );  //Specifying what to do with the data
		ROS_INFO("service on\n");
		vel_pub_ = nh_.advertise<geometry_msgs::Twist>("cmd_vel", 1);
		objectDetectedPublisher = nh_.advertise<C23_ObjectRecognition::C23C0_OD>("C23/object_detected", 1);
    objectDeminsionsPublisher = nh_.advertise<C23_ObjectRecognition::C23C0_ODIM>("C23/object_deminsions", 1);
		
	  }
/**
* The call back function executed when a service is requested
* it must return true in order to work properly
* @param req the request message, generated by the node requesting the service
* @param res the response message, generated by the service node when a service is requested
*/
/*
bool proccess(C23_ObjectRecognition::C23::Request  &req,
	C23_ObjectRecognition::C23::Response &res )
{
  ROS_INFO("recived request, tying to fetch data\n");

  return true;
}
*/

/**
* The call back function executed when a data is available
* @param left_msg ROS mesage with image data from the left camera topic
* @param right_msg ROS mesage with image data from the right camera topic
*/
	   
bool C23_Node::detectAndTrack(const char* target) {

    ROS_INFO("C23_Node::detectAndTrack\n");
    if(tldh_ != NULL) {
        free(tldh_);
        tldh_ = NULL;
    }
    sprintf(_path,"%s/models/%s.mdl%c",ros::package::getPath("C23_ObjectRecognition").c_str(),target,'\0');
    x = -1;
    detector.initialize("carEntry");
    _mode = TRACKING;
    done_processing = true;
    detect=true;
    return true;

}

bool C23_Node::learnObject(const char* target) {
    ROS_INFO("C23_Node:: learning new object: %s.",target);
    if(tldh_ != NULL) {
        free(tldh_);
        tldh_ = NULL;
    }
  
    sprintf(_path,"%s/models/%s.mdl%c",ros::package::getPath("C23_ObjectRecognition").c_str(),target,'\0');
    _mode = LEARNING;
    
    done_processing = true;
    detect = true;
    return true;
}


	
void C23_Node::callback(const sensor_msgs::ImageConstPtr& left_msg,const sensor_msgs::ImageConstPtr& right_msg){
 
 cv_bridge::CvImagePtr cv_ptr;
 static int count = 1;
 ROS_INFO("I was called with: %d",done_processing);
 if(detect && done_processing) {
 
    done_processing = false;

    try {
        cv_ptr = cv_bridge::toCvCopy(left_msg,enc::BGR8);
    }
    
    catch (cv_bridge::Exception& e)
    {
      ROS_ERROR("cv_bridge exception: %s", e.what());
      return;
    }

    IplImage tosave=cv_ptr->image;
    int percent = 100;
    IplImage *destination = cvCreateImage
    ( cvSize((int)((tosave.width*percent)/100) , (int)((tosave.height*percent)/100) ),
                             tosave.depth, tosave.nChannels );
    

    cvResize(&tosave, destination);
    detector.initialize("CarEntry");
    if(tldh_ == NULL) {

        char buf[10000];
      
      
        tldh_ = new C23_Node_TLD_Handler(_mode, _path);
        tldh_->init(destination);
    } else {
   
                                    //  #ifdef CREATING_IMAGES
                                    //      Mat img(destination);
                                         // char buff[1000];
                                    //     sprintf(buff,"training/car_driver/yair/image%d.jpg%c",i,'\0');
                                     //     imwrite(buff,img);
                                     //     i++;
                                     //     return;
        ROS_INFO("Trying TLD...");
        tldh_->processFrame(destination, &x, &y, &width, &height, &confident);
        if(x == -1) {
        ROS_INFO("Failed %d",count);
          count++;
        }
        if(count == 50) {
          detector.detect(destination);
          if(detector._x != -1) {
            delete tldh_;
            tldh_ = new C23_Node_TLD_Handler(_mode, _path);
            tldh_->setBB(destination,detector._x,detector._y,detector._width,detector._height);
            count = 1;
            ROS_INFO("initializing tld with bb: %d,%d,%d,%d",detector._x,detector._y,detector._width,detector._height);
            done_processing = true;
          
          }
        }
                                       /*   if(x!= -1) {
                                            cvSetImageROI(destination,cvRect(x,y,width,height));
                                            IplImage *tmp =  cvCreateImage ( cvSize(width,height),tosave.depth, tosave.nChannels );

                                            cvCopy(destination,tmp,NULL);

                                            cvResetImageROI(destination);
                                            cvReleaseImage(destination);
                                            IplImage* img = cvCloneImage(tmp);
                                            Mat kuku;
                                            Mat imgMat(img); 
                                            Size s(210*1.5,132*1.5);

                                            resize(imgMat,kuku, s);
                                            char buff[1000];

                                            sprintf(buff,"training/car_front/positive/car_rear%d.jpg%c",i,'\0');
                                            ROS_INFO("Saving: %s",buff);
                                            imwrite(buff,kuku);
                                            i++;
                                           // if(i > 671) { return; }
                                         } */
                                     //    #endif
        
       
        C23_ObjectRecognition::C23C0_OD msg;
        C23_ObjectRecognition::C23C0_ODIM msg2;
        string object = "CarEntry";
        msg.ObjectDetected = (x != -1 ? 1 : 0);
        msg2.x = x;
        msg2.y = y;
        msg2.width = width;
        msg2.height = height;
        msg2.Object = object;
        msg.Object = object;
        objectDeminsionsPublisher.publish(msg2);
        objectDetectedPublisher.publish(msg);
    }
    done_processing = true;
    
   }
}
void C23_Node::startDetection() {
    ROS_INFO("C23_Node::startDetection\n");
    detect=true;
}
void C23_Node::stopDetection() {
    ROS_INFO("C23_Node::stopDetection\n");
    if(tldh_ != NULL) {
        free(tldh_);
        tldh_ = NULL;
    }
    detect=false;
}
	  



