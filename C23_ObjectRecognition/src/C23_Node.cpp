/**************************************************************************************
 * This is a template for the C23_ObjectRecognition module for the robil project
 * The C23_ObjectRecognition module goal is to provide a recognition of the object searched in the given frame
 *
 * There is no actual input/output at this time, this goes according to the current milestone
 * set at the robil managment meeting
 * 
 **************************************************************************************/
#include "C23_Node.hpp"
#include <ros/package.h>
#include <C23_ObjectRecognition/C23C0_OD.h>
#include <C23_ObjectRecognition/C23C0_ODIM.h>




static const char WINDOW[] = "Image window";


C23_Node::C23_Node(std::string left_camera,std::string right_camera) :
		it_(nh_),
		tldh_(NULL),
		x(-1), y(-1), width(-1), height(-1),
		left_image_sub_( it_, left_camera, 1 ),
		right_image_sub_( it_, right_camera, 1 ),
		sync( MySyncPolicy( 10 ), left_image_sub_, right_image_sub_ ),
		detect(false),done_processing(true)
	  {
	    //ready=false;
		sync.registerCallback( boost::bind( &C23_Node::callback, this, _1, _2 ) );  //Specifying what to do with the data
		//service = nh_.advertiseService("C23", &C23_Node::proccess, this); //Specifying what to do when a reconstructed 3d scene is requested
		ROS_INFO("service on\n");
		objectDetectedPublisher = nh_.advertise<C23_ObjectRecognition::C23C0_OD>("C23/object_detected", 1);
        objectDeminsionsPublisher = nh_.advertise<C23_ObjectRecognition::C23C0_ODIM>("C23/object_deminsions", 1);
		
	  }
/**
* The call back function executed when a service is requested
* it must return true in order to work properly
* @param req the request message, generated by the node requesting the service
* @param res the response message, generated by the service node when a service is requested
*/
/*
bool proccess(C23_ObjectRecognition::C23::Request  &req,
	C23_ObjectRecognition::C23::Response &res )
{
  ROS_INFO("recived request, tying to fetch data\n");

  return true;
}
*/

/**
* The call back function executed when a data is available
* @param left_msg ROS mesage with image data from the left camera topic
* @param right_msg ROS mesage with image data from the right camera topic
*/
	   
bool C23_Node::detectAndTrack(const char* target) {

    ROS_INFO("C23_Node::detectAndTrack\n");
    if(tldh_ != NULL) {
        free(tldh_);
        tldh_ = NULL;
    }
    sprintf(_path,"%s/models/%s.mdl%c",ros::package::getPath("C23_ObjectRecognition").c_str(),target,'\0');
    x = -1;
    
    _mode = TRACKING;
    done_processing = true;
    detect=true;
    return true;

}

bool C23_Node::learnObject(const char* target) {
    ROS_INFO("C23_Node:: learning new object: %s.",target);
    if(tldh_ != NULL) {
        free(tldh_);
        tldh_ = NULL;
    }
    sprintf(_path,"%s/models/%s.mdl%c",ros::package::getPath("C23_ObjectRecognition").c_str(),target,'\0');
    _mode = LEARNING;
    
    done_processing = true;
    detect = true;
    return true;
}


	
void C23_Node::callback(const sensor_msgs::ImageConstPtr& left_msg,const sensor_msgs::ImageConstPtr& right_msg){
 
 cv_bridge::CvImagePtr cv_ptr;
    
 if(detect && done_processing) {
    done_processing = false;

    try {
        cv_ptr = cv_bridge::toCvCopy(left_msg,enc::BGR8);
    }
    
    catch (cv_bridge::Exception& e)
    {
      ROS_ERROR("cv_bridge exception: %s", e.what());
      return;
    }

    IplImage tosave=cv_ptr->image;
    int percent = 30;
    IplImage *destination = cvCreateImage
    ( cvSize((int)((tosave.width*percent)/20) , (int)((tosave.height*percent)/20) ),
                             tosave.depth, tosave.nChannels );
    

    cvResize(&tosave, destination);

    if(tldh_ == NULL) {

        char buf[10000];
      
      
        tldh_ = new C23_Node_TLD_Handler(_mode, _path);

        tldh_->init(destination);
    } else {

        
        tldh_->processFrame(destination, &x, &y, &width, &height, &confident);
        C23_ObjectRecognition::C23C0_OD msg;
        C23_ObjectRecognition::C23C0_ODIM msg2;
        msg.ObjectDetected = (x != -1 ? 1 : 0);
        msg2.x = x;
        msg2.y = y;
        msg2.width = width;
        msg2.height = height;
        objectDeminsionsPublisher.publish(msg2);
        objectDetectedPublisher.publish(msg);
    }
    done_processing = true;
   }
}
void C23_Node::startDetection() {
    ROS_INFO("C23_Node::startDetection\n");
    detect=true;
}
void C23_Node::stopDetection() {
    ROS_INFO("C23_Node::stopDetection\n");
    if(tldh_ != NULL) {
        free(tldh_);
        tldh_ = NULL;
    }
    detect=false;
}
	  



