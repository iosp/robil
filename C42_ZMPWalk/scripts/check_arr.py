#!/usr/bin/env python

###################################################################################
####	                                                                         ##
####	zmp control main                                                         ##
####	last updated - Israel 25/12/12	                                         ##
####                                                                             ##
####    run this script to initiate zmp node           	                         ##
####    to start walking: rostopic pub /zmp_walk_command std_msgs/Int32 1        ##
####    to stop walking:  rostopic pub /zmp_walk_command std_msgs/Int32 0	 ##
####                                         	                                 ##
####    this node runs with parameters generated by matlab and are stored	 ##
####    in the file '/src/parameters'.	                                         ##
####    the walking patern in governed by the parameters: 			 ##
####    step_length,step_width and step_time		                         ##
####	                                                                  	 ##
###################################################################################			

# Ros Parameters Initialization

from numpy import *
import sys,os.path
from pylab import *
from zmp_profiles import *
from preview_buffer import ZMP_Preview_Buffer


##################################################################
##                                                              ##
##  plot:  zmp_profile.py                                       ##
##                                                              ##
##################################################################

######### Profile: Start_lateral_y_weight_to_left_foot ###########

# Walking Parameters
ZMP_start_pos = 0.0 #0.05
ZMP_start_pos_step1 = 0.0
step_width = 0.2
step_length = 0.1
step_length2 = 0.2
trans_ratio_of_step = 0.8 #0.5
trans_slope_steepens_factor = 2
step_time = 10
sample_time = 0.01
p_ref_y_old_correction = 0 # step_width/2 # for old version

preview_buffer_i = 300

## Testing zmp_profiles:

p_ref_x_start = Start_sagital_x(ZMP_start_pos, step_length, trans_ratio_of_step, trans_slope_steepens_factor, step_time, sample_time)
p_ref_y_start = Start_lateral_y_weight_to_left_foot(ZMP_start_pos, step_width, trans_ratio_of_step, trans_slope_steepens_factor, step_time, sample_time)

p_res_x_forward_step = Step_forward_x(ZMP_start_pos_step1, step_length, trans_ratio_of_step, trans_slope_steepens_factor, step_time, sample_time)
p_res_x_forward_step2 = Step_forward_x(ZMP_start_pos_step1, step_length2, trans_ratio_of_step, trans_slope_steepens_factor, step_time, sample_time)

p_ref_y_step_right = Step_onto_right_foot(ZMP_start_pos_step1, step_width, trans_ratio_of_step, trans_slope_steepens_factor, step_time, sample_time)
p_ref_y_step_left = Step_onto_left_foot(ZMP_start_pos_step1, step_width, trans_ratio_of_step, trans_slope_steepens_factor, step_time, sample_time)

p_ref_x_stop = Stop_sagital_x(ZMP_start_pos, step_length, trans_ratio_of_step, trans_slope_steepens_factor, step_time, sample_time)
p_ref_y_stop_from_left = Stop_lateral_y_from_left_foot(ZMP_start_pos, step_width, trans_ratio_of_step, trans_slope_steepens_factor, step_time, sample_time)
p_ref_y_stop_from_right = Stop_lateral_y_from_right_foot(ZMP_start_pos, step_width, trans_ratio_of_step, trans_slope_steepens_factor, step_time, sample_time)

p_ref_const_x = Constant_Template(step_length*3, step_time, sample_time)

p_ref_x_r = r_[ p_ref_x_start, step_length/2 + p_res_x_forward_step2, step_length*1/2 + step_length2 + p_res_x_forward_step, step_length*3/2 + step_length2 + p_ref_x_stop ] # 
p_ref_x = r_[ p_ref_x_start, step_length/2 + p_res_x_forward_step, step_length*3/2 + p_res_x_forward_step, step_length*5/2 + p_ref_x_stop, p_ref_const_x ]

p_ref_y = r_[ p_ref_y_old_correction + p_ref_y_start, p_ref_y_old_correction + p_ref_y_step_right, p_ref_y_old_correction + p_ref_y_step_left, p_ref_y_old_correction + p_ref_y_stop_from_left ]
p_ref_y_c = r_[ p_ref_y_old_correction + p_ref_y_start, p_ref_y_old_correction + p_ref_y_step_right, p_ref_y_old_correction + p_ref_y_step_left, p_ref_y_old_correction + p_ref_y_step_right, p_ref_y_old_correction + p_ref_y_stop_from_right ]


# ## Testing preview_buffer:
# Preview_Sagital_x = ZMP_Preview_Buffer('Sagital X', 720, 4*step_time/sample_time, 0 ) #name, preview_sample_size, max_step_samples, precede_time_samples
# Preview_Lateral_y = ZMP_Preview_Buffer('Lateral Y', 720, 4*step_time/sample_time, 0 ) #name, preview_sample_size, max_step_samples, precede_time_samples

# Preview_Sagital_x.load_NewStep( p_ref_x_start, p_res_x_forward_step)
# Preview_Lateral_y.load_NewStep( p_ref_y_start, r_[ p_ref_y_step_right, p_ref_y_step_left ] )

# count = 0
# for num in range(0,preview_buffer_i):
#     p_ref_x_temp = Preview_Sagital_x.update_Preview()
#     p_ref_y_temp = Preview_Lateral_y.update_Preview()
#     count += 1

# rospy.loginfo("check_arr: count = %f" % (count ) )

# p_ref_x_r = r_[ zeros(preview_buffer_i-1), p_ref_x_temp ]
# p_ref_y_c = r_[ zeros(preview_buffer_i-1), p_ref_y_temp ]

# ## Test transition_Min_jerk:
# #!!! transition_Min_jerk(x0,xf,N) = r_[ transition_Min_jerk_firstHalf(x0,xm, floor(N/2), N) , transition_Min_jerk_secondHalf(xm,xf, N-floor(N/2), N) ] !!!
# N = 101
# half_N = floor(N/2)
# p_trans = transition_Min_jerk(5,15, N )
# p_trans1 = transition_Min_jerk_firstHalf(5,10, half_N, N)
# p_trans2 = transition_Min_jerk_secondHalf(10,15, N-half_N, N)
# plot(p_trans,'g', r_[p_trans1, p_trans2],'r--') #plot(p_ref_y,'b-')
# grid(True)
# show()

plot(p_ref_x,'g--', p_ref_x_r,'r-', p_ref_y,'b--', p_ref_y_c,'c-') #plot(p_ref_y,'b-')
grid(True)
show()



# #from zmp_main.py:
# time_step  =  0.01  # [sec] 

# # Walking Parameters 

# step_length = 0.10 #0.01  # [m]
# step_width  = 0.18  # 0.178  # [m]
# step_time   = 8 #1   # [sec]
# bend_knees  = 0.04  # [m]    
# step_height = 0.0001 #0.03 #0.05  # [m] 
# half_trans_ratio = 0.3 #0.5 # units fraction: 0-0.5

# # Sigmoid Plot

# a =  2 #1 #1 #5 # 50  #100  # change slop of ZMP -> com
# s =  arange(-half_trans_ratio*step_time, half_trans_ratio*step_time+time_step , time_step) #arange(-3*step_time, 3*step_time+time_step , time_step) #arange(-1.5*step_time,1.5*step_time+time_step , time_step) # arange(-0.1*step_time,0.1*step_time+time_step , time_step) #
# sigmoid_x = step_length/(1+exp(-a*s))
# sigmoid_y = step_width/(1+exp(-a*s))

# # plot(sigmoid_y)
# # show()


# # Pref Initialization

# t1 = arange(0 , step_time-2*half_trans_ratio*step_time+time_step , time_step)    # arange(0 , step_time-2*0.1*step_time+time_step , time_step)
# t0x = arange(0 , 2*step_time-half_trans_ratio*step_time+time_step   , time_step) # arange(0 , 2*step_time-0.1*step_time+time_step   , time_step)
# t0y = arange(0 , step_time-half_trans_ratio*step_time+time_step   , time_step)   # arange(0 , step_time-0.1*step_time+time_step   , time_step)

# p_ref1x = step_length*ones(( len(t1) ))
# p_ref1y = step_width*ones(( len(t1) ))
# p_ref0 = zeros(( len(t1)-1 ))
# p_ref0_0x = zeros(( len(t0x)-1 ))
# p_ref0_0y = (step_width/2)*ones(( len(t0y)-1 ))

# Leg = 1
# left = 1 # when Leg=1 right leg is swing leg


# D = 0.0
# x     = array([0.0 , 0.0 , 0.0])[:,newaxis]   
# y     = array([step_width/2 , 0.0 , 0.0])[:,newaxis]                             
# p_x   = 0.0
# p_y   = 0.0
# sum_e_x = 0
# sum_e_y = 0
# k     = 1
# step_length_z = step_length;
# step_time_z = step_time;
# pre_step = 1
# first_step = 0
# full_step = 0
# last_step_mes = 0 
# go = 1
# steps_count = -1
# last_step = 0
# step_done = 0
# swing_x_v = []
# swing_z_v = []
# p_ref_x = r_[ p_ref0_0x , sigmoid_x , p_ref1x ]
# p_ref_y = r_[ p_ref0_0y , sigmoid_y/2+step_width/2 , p_ref1y ]
# swing_z_t_more_double_support = 0
# swing_x_t_more_double_support = 0


# plot(p_ref_x,'g-',p_ref_y,'b-') #plot(p_ref_y)
# grid(True)
# #legend()
# #show()
# # figure(2)
# # plot(p_ref_y) #plot(sigmoid_y)

# # show()

# # ref for a few steps
# num_of_steps = 4
# NL = num_of_steps*step_time*100

# ## sagital ref (x) ##
# while len(p_ref_x) < k+NL:
 
#     D = D + step_length

#     a = p_ref_x[0:len(p_ref_x)-1]

#     b = sigmoid_x[0:len(sigmoid_x)-1]         
#     c = p_ref1x

#     d = r_[b,c]+D*ones(( len(r_[b,c]) )) #step_length*ones(2*len(r_[b,c]))#                            for debuging
#     p_ref_x = r_[a,d]

# ## lateral ref (y) ##
# while len(p_ref_y) < k+NL:
 
#     if left == 1:

#         a = p_ref_y[0:len(p_ref_y)-1]
  
#         b = sigmoid_y[0:len(sigmoid_y)-1][::-1]      
#         c = p_ref0[0:len(p_ref1y)]
#         d = r_[b,c]#step_width/2*ones(3*len(p_ref1y))#                              for debuging
   
#         p_ref_y = r_[a,d]

#         left = 0

#     elif left == 0:

#         a = p_ref_y[0:len(p_ref_y)-1]

#         b = sigmoid_y[0:len(sigmoid_y)-1]         
#         c = p_ref1y[0:len(p_ref1y)]
#         d = r_[b,c]#step_width/2*ones(3*len(p_ref1y))#                                 for debuging

#         p_ref_y = r_[a,d]

#         left = 1

# figure(2)
# plot(p_ref_x,'g-',p_ref_y,'b-')
# grid(True)

# show()





