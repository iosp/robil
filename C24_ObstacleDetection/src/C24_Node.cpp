/**************************************************************************************
 * This is a template for the C24_ObstacleDetection module for the robil project
 * The C24_ObstacleDetection module goal is to provide an obstacle detection on demand
 *
 * There is no actual input/output at this time, this goes according to the current milestone
 * set at the robil managment meeting
 * 
 **************************************************************************************/

#include "ros/ros.h"
#include "C24_ObstacleDetection/C24.h"
#include "ObstacleDetectionServer.hpp"
#include <C22_GroundRecognitionAndMapping/C22C24.h>
#include "ros/service.h"
#include <nav_msgs/Odometry.h>
#include <geometry_msgs/PoseWithCovariance.h>
#include <tf/transform_listener.h>




/**
 * this class represent the C24_Node,
 * it subscribe to two camera/image topics and provide the path
 **/
class C24_Node{

public:

	/**
	 * constructor, initializes the ROS node, subscribe it to the given topics and instruct it to provide the service
	 * @param left_camera the left camera image topic
	 * @param right_camera the right camera image topic
	 */
	  C24_Node(int argc, char **argv)
	  {
		client = nh_.serviceClient<C22_GroundRecognitionAndMapping::C22C24>("C22/C24");
		sub_=nh_.subscribe("ground_truth_odom",1,&C24_Node::callback, this);
		service = nh_.advertiseService("C24", &C24_Node::proccess, this); //Specifying what to do when a reconstructed 3d scene is requested
		ROS_INFO("service on\n");
		boost::thread mythread( &C24_Node::startActionServer,this,argc,argv);
	  }


	  void startActionServer(int argc, char **argv){
		  ros::init(argc, argv, "C24_ObstacleDetectionTaskServer");
		  taskserver=new ObstacleDetectionServer();
		  while(ros::ok()){

		  }
	  }


	  /**
	   * The call back function executed when a service is requested
	   * it must return true in order to work properly
	   * @param req the request message, generated by the node requesting the service
	   * @param res the response message, generated by the service node when a service is requested
	   */
	  bool proccess(C24_ObstacleDetection::C24::Request  &req,
			C24_ObstacleDetection::C24::Response &res )
	  {
		  C22_GroundRecognitionAndMapping::C22C24 srv;
		  if (client.call(srv))
		  {
			  res.map.row.resize(srv.response.drivingPath.row.size());
			  for (unsigned int i=0;i<srv.response.drivingPath.row.size();i++){
				 res.map.row.at(i).column.resize(srv.response.drivingPath.row.size());
			  	 for (unsigned int j=0;j<srv.response.drivingPath.row.size();j++){
			  		  if (srv.response.drivingPath.row.at(i).column.at(j).status==0){
			  			  float height=srv.response.drivingPath.row.at(i).column.at(j).height;
			  			  //std::cout<<"block: "<<height -zhead -zpelvis-0.4<< std::endl;
			  			  if(std::abs(height -zhead -zpelvis-0.5)>0.25){
			  						std::cout<<"block: "<<height -zhead -zpelvis-0.4<< std::endl;
			  						res.map.row.at(i).column.at(j).status=1;

			  				}else{
			  					res.map.row.at(i).column.at(j).status=0;
			  				}


			  		  }else{
			  			  if(srv.response.drivingPath.row.at(i).column.at(j).status==1){
			  			  	  res.map.row.at(i).column.at(j).status=1;
			  		  	  }else{
			  		  	  	  res.map.row.at(i).column.at(j).status=2;
			  		  	  }
			  		  }
			  	 }
			  }
		  }
		  else
		  {
			  ROS_ERROR("couldn't get a reply from C22\n");
			  return false;
		  }
		  return true;
	  }


	  /**
	   * The call back function executed when a data is available
	   * @param left_msg ROS mesage with image data from the left camera topic
	   * @param right_msg ROS mesage with image data from the right camera topic
	   */
	  void callback(const nav_msgs::OdometryConstPtr& pos_msg){
		  zpelvis=pos_msg->pose.pose.position.z;
	  }

  float zhead;
  float zpelvis;
private:
  ros::NodeHandle nh_;
  ros::Subscriber sub_;
  ros::ServiceServer service;
  ros::ServiceClient client;
  ObstacleDetectionServer * taskserver;
};

int main(int argc, char **argv)
{
  ros::init(argc, argv, "C24_ObstacleDetection");
  C24_Node *my_node=new C24_Node(argc, argv);

  tf::TransformListener listener;

  ros::Rate rate(10.0);
  while (ros::ok()){
	tf::StampedTransform transform;
	try{
	  listener.lookupTransform("pelvis", "head",
							   ros::Time(0), transform);
	}
	catch (tf::TransformException ex){
	  ROS_ERROR("%s",ex.what());
	}
	my_node->zhead=transform.getOrigin().z();

	ros::spinOnce();
  }
  return 0;
}

